// The JSONC Groovy DSL that defines the JSON configuration needed to launch a 
// Lappsgrid appliance inside Amazon ECS (Elastic Container Service).
//
// This script should be included from an appliance specific "master" script that 
// defines the following:
// 1. containers: List<String>
//    The list of containers that will be started along with galaxy.  This list SHOULD
//    NOT contain the Galaxy container.
// 2. galaxy_image: String
//    The name of the Galaxy Docker container, with organization if needed, to be
//    used in the appliance.  This image should already be built and pushed to the
//    Docker hub if it is not available locally.
// 3. cluster: String
//    The name of the AWS cluster
// 4. ports
// 5. cpu
// 6. memory
// See: https://console.aws.amazon.com/ecs/home?region=us-east-1#/taskDefinitions

/***************************************************/
/*** NO CHANGES SHOULD BE NEEDED TO THIS SCRIPT. ***/
/***************************************************/

/**
 * Generates a list of mount point declarations. Also updates the volumes
 * map is the volume has not been declared before.
 */
List mount(List mounts, Map volumes) {
	def result = []
	mounts.each { mount ->
		if (volumes[mount.name]) {
			// If this volume has been mounted already ensure that the source
			// directories are the same.
			if (volumes[mount.name] != mount.source) {
				throw new IllegalStateException("The host paths for the volume ${mount.name} are different.")
			}
		}
		else {
			volumes[mount.name] = mount.source						
		}
		result << [
			sourceVolume: mount.name,
			containerPath: mount.container,
			readOnly: mount.readOnly
		]
	}
	return result
}

// The Docker images to be used for the appliance. 
// TODO: We should not assume that the organization will always be lappsgrid.
def images = containers.inject([:]) { map,name -> 	
	map[name] = "lappsgrid/$name"; 
	return map 
}

// A function (closure) that generates the data structure (a list of maps)
// that is used to configure the port mappings for an image.
def map = { host, container ->
	[[
		containerPort: container,
		hostPort: host,
		protocol: 'tcp'
	]]
}

// Ports assigned to the service containers.
int port = 8000  

// Map used to store volumes used in mount point definitions. 
def volumeDefs = [:]

// Start generating JSON.
containerDefinitions (
	containers.collect { name ->
		def definition = [
			name: name,
			image: images[name],
			cpu: cpu[name] ?: cpu.default,
			memory: memory[name] ?: memory.default,
			essential: true,
			portMappings: map(++port, 8080),
			command: [ '/usr/bin/startup' ]
		]
		if (mounts[name]) {
			println "Getting mount points for $name"
			definition.mountPoints = mount(mounts[name], volumeDefs)
			println "Mounted ${definition.mountPoints.size()} points."
		}
		return definition
	} << [
		name: 'galaxy',
		image: galaxy_image,
		cpu: cpu.galaxy ?: cpu.default,
		memory: memory.galaxy ?: memory.default,
		essential: true,
		priviledged: true,
		portMappings: map(80, 80),
		command: ['/usr/local/starup'],
		links: containers,
		mountPoints: mount(mounts.galaxy, volumeDefs)
	] 
)

// Declare the volumes used in the mount points.
def vol_list = []
volumeDefs.each { name,path ->
	vol_list << [
		name: name,
		host: [
			sourcePath: path
		]
	]
}

// Generate the json
volumes vol_list

family cluster

